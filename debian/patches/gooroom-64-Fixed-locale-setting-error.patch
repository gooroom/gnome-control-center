diff --git a/panels/region/cc-region-panel.c b/panels/region/cc-region-panel.c
index aced978..2173118 100644
--- a/panels/region/cc-region-panel.c
+++ b/panels/region/cc-region-panel.c
@@ -40,6 +40,11 @@
 #include <libgnome-desktop/gnome-languages.h>
 #include <libgnome-desktop/gnome-xkb-info.h>
 
+#ifdef HAVE_IBUS
+#include <ibus.h>
+#include "cc-ibus-utils.h"
+#endif
+
 #include <act/act.h>
 
 #define GNOME_DESKTOP_INPUT_SOURCES_DIR "org.gnome.desktop.input-sources"
@@ -51,12 +56,7 @@
 #define INPUT_SOURCE_TYPE_XKB "xkb"
 #define INPUT_SOURCE_TYPE_IBUS "ibus"
 
-#define DEFAULT_LOCALE "ko_KR.utf-8"
-#define XSESSIONRC ".xsessionrc"
-
-static const gchar *xsessionrc_template = "export LANG=%s\n";
-                                           //export LANGUAGE=%s:%s\n
-                                           //export ";
+#define DEFAULT_LOCALE "en_US.utf-8"
 
 typedef enum {
         CHOOSE_LANGUAGE,
@@ -97,8 +97,24 @@ struct _CcRegionPanel {
         gchar *system_language;
         gchar *system_region;
 
+        GtkWidget *input_section;
+        GtkWidget *options_button;
+        GtkWidget *input_list;
+        GtkWidget *add_input;
+        GtkWidget *remove_input;
+        GtkWidget *move_up_input;
+        GtkWidget *move_down_input;
+        GtkWidget *show_config;
+        GtkWidget *show_layout;
         GtkWidget *restart_button;
         GtkWidget *language_list;
+
+        GSettings *input_settings;
+        GnomeXkbInfo *xkb_info;
+#ifdef HAVE_IBUS
+        IBusBus *ibus;
+        GHashTable *ibus_engines;
+#endif
 };
 
 CC_PANEL_REGISTER (CcRegionPanel, cc_region_panel)
@@ -126,6 +142,12 @@ cc_region_panel_finalize (GObject *object)
         g_clear_object (&self->localed);
         g_clear_object (&self->session);
         g_clear_object (&self->locale_settings);
+        g_clear_object (&self->input_settings);
+        g_clear_object (&self->xkb_info);
+#ifdef HAVE_IBUS
+        g_clear_object (&self->ibus);
+        g_clear_pointer (&self->ibus_engines, g_hash_table_destroy);
+#endif
         g_free (self->language);
         g_free (self->region);
         g_free (self->system_language);
@@ -177,7 +199,7 @@ restart_now (CcRegionPanel *self)
 
         g_dbus_proxy_call (self->session,
                            "Logout",
-                           g_variant_new ("(u)", 1),
+                           g_variant_new ("(u)", 0),
                            G_DBUS_CALL_FLAGS_NONE,
                            -1, NULL, NULL, NULL);
 }
@@ -262,75 +284,12 @@ maybe_notify_finish (GObject      *source,
                                  NULL))
                 return;
 
-        if (!(self->login)){
-                if (mnd->category == LC_MESSAGES) {
-
-                        if (!gnome_parse_locale (self->region,
-                                                 NULL,
-                                                 &target_country_code,
-                                                 NULL,
-                                                 NULL))
-                                return;
-
-                        if (!gnome_parse_locale (mnd->target_locale,
-                                                 &target_lang_code,
-                                                 NULL,
-                                                 NULL,
-                                                 NULL))
-                                return;
-
-                } else {
-
-                        if (!gnome_parse_locale (self->language,
-                                                 &target_lang_code,
-                                                 NULL,
-                                                 NULL,
-                                                 NULL))
-                                return;
-
-                        if (!gnome_parse_locale (mnd->target_locale,
-                                                 NULL,
-                                                 &target_country_code,
-                                                 NULL,
-                                                 NULL))
-                                return;
-
-                }
-        } else {
-                if (mnd->category == LC_MESSAGES) {
-
-                        if (!gnome_parse_locale (self->system_region,
-                                                 NULL,
-                                                 &target_country_code,
-                                                 NULL,
-                                                 NULL))
-                                return;
-
-                        if (!gnome_parse_locale (mnd->target_locale,
-                                                 &target_lang_code,
-                                                 NULL,
-                                                 NULL,
-                                                 NULL))
-                                return;
-
-                } else {
-
-                        if (!gnome_parse_locale (self->system_language,
-                                                 &target_lang_code,
-                                                 NULL,
-                                                 NULL,
-                                                 NULL))
-                                return;
-
-                        if (!gnome_parse_locale (mnd->target_locale,
-                                                 NULL,
-                                                 &target_country_code,
-                                                 NULL,
-                                                 NULL))
-                                return;
-
-                }
-        }
+        if (!gnome_parse_locale (mnd->target_locale,
+                                 &target_lang_code,
+                                 &target_country_code,
+                                 NULL,
+                                 NULL))
+                return;
 
         if (g_str_equal (current_lang_code, target_lang_code) == FALSE ||
             g_str_equal (current_country_code, target_country_code) == FALSE)
@@ -365,7 +324,7 @@ maybe_notify (CcRegionPanel *self,
                            mnd);
 }
 
-static void set_localed_locale (CcRegionPanel *self);
+static void set_localed_locale (CcRegionPanel *self, gboolean lang_changed);
 
 static void
 set_system_language (CcRegionPanel *self,
@@ -377,22 +336,7 @@ set_system_language (CcRegionPanel *self,
         g_free (self->system_language);
         self->system_language = g_strdup (language);
 
-        set_localed_locale (self);
-}
-
-static void
-set_user_language (CcRegionPanel *self,
-                   const gchar   *language)
-{
-        g_autofree gchar *xsessionrc;
-        g_autofree gchar *contents;
-
-
-        xsessionrc = g_build_filename (g_get_home_dir (), XSESSIONRC, NULL);
-        contents = g_strdup_printf (xsessionrc_template, language);
-
-        g_file_set_contents (xsessionrc, contents, -1, NULL);
-        act_user_set_language (self->user, language);
+        set_localed_locale (self, TRUE);
 }
 
 static void
@@ -404,11 +348,11 @@ update_language (CcRegionPanel *self,
         } else {
                 if (g_strcmp0 (language, self->language) == 0)
                         return;
-                set_user_language (self, language);
+                act_user_set_language (self->user, language);
                 if (self->login_auto_apply)
                         set_system_language (self, language);
+                maybe_notify (self, LC_MESSAGES, language);
         }
-        maybe_notify (self, LC_MESSAGES, language);
 }
 
 static void
@@ -436,7 +380,7 @@ set_system_region (CcRegionPanel *self,
         g_free (self->system_region);
         self->system_region = g_strdup (region);
 
-        set_localed_locale (self);
+        set_localed_locale (self, FALSE);
 }
 
 static void
@@ -451,8 +395,8 @@ update_region (CcRegionPanel *self,
                 g_settings_set_string (self->locale_settings, KEY_REGION, region);
                 if (self->login_auto_apply)
                         set_system_region (self, region);
+                maybe_notify (self, LC_TIME, region);
         }
-        maybe_notify (self, LC_TIME, region);
 }
 
 static void
@@ -524,6 +468,11 @@ show_region_chooser (CcRegionPanel *self)
         gtk_window_present (GTK_WINDOW (chooser));
 }
 
+static void show_input_chooser (CcRegionPanel *self);
+static void remove_selected_input (CcRegionPanel *self);
+static void move_selected_input (CcRegionPanel *self,
+                                 SystemOp       op);
+
 static void
 permission_acquired (GObject      *source,
                      GAsyncResult *res,
@@ -548,6 +497,16 @@ permission_acquired (GObject      *source,
                 case CHOOSE_REGION:
                         show_region_chooser (self);
                         break;
+                case ADD_INPUT:
+                        show_input_chooser (self);
+                        break;
+                case REMOVE_INPUT:
+                        remove_selected_input (self);
+                        break;
+                case MOVE_UP_INPUT:
+                case MOVE_DOWN_INPUT:
+                        move_selected_input (self, self->op);
+                        break;
                 default:
                         g_warning ("Unknown privileged operation: %d\n", self->op);
                         break;
@@ -664,6 +623,262 @@ setup_language_section (CcRegionPanel *self)
         update_region_from_setting (self);
 }
 
+#ifdef HAVE_IBUS
+static void
+update_ibus_active_sources (CcRegionPanel *self)
+{
+        g_autoptr(GList) rows = NULL;
+        GList *l;
+        GtkWidget *row;
+        const gchar *type;
+        const gchar *id;
+        IBusEngineDesc *engine_desc;
+        GtkWidget *label;
+
+        rows = gtk_container_get_children (GTK_CONTAINER (self->input_list));
+        for (l = rows; l; l = l->next) {
+                row = l->data;
+                type = g_object_get_data (G_OBJECT (row), "type");
+                id = g_object_get_data (G_OBJECT (row), "id");
+                if (g_strcmp0 (type, INPUT_SOURCE_TYPE_IBUS) != 0)
+                        continue;
+
+                engine_desc = g_hash_table_lookup (self->ibus_engines, id);
+                if (engine_desc) {
+                        g_autofree gchar *display_name = engine_get_display_name (engine_desc);
+                        label = GTK_WIDGET (g_object_get_data (G_OBJECT (row), "label"));
+                        gtk_label_set_text (GTK_LABEL (label), display_name);
+                }
+        }
+}
+
+static void
+update_input_chooser (CcRegionPanel *self)
+{
+        GtkWidget *chooser;
+
+        chooser = g_object_get_data (G_OBJECT (self), "input-chooser");
+        if (!chooser)
+                return;
+
+        cc_input_chooser_set_ibus_engines (chooser, self->ibus_engines);
+}
+
+static void
+fetch_ibus_engines_result (GObject       *object,
+                           GAsyncResult  *result,
+                           CcRegionPanel *self)
+{
+        g_autoptr(GList) list = NULL;
+        GList *l;
+        g_autoptr(GError) error = NULL;
+
+        list = ibus_bus_list_engines_async_finish (IBUS_BUS (object), result, &error);
+        if (!list && error) {
+                if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+                        g_warning ("Couldn't finish IBus request: %s", error->message);
+                return;
+        }
+
+        /* Maps engine ids to engine description objects */
+        self->ibus_engines = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_object_unref);
+
+        for (l = list; l; l = l->next) {
+                IBusEngineDesc *engine = l->data;
+                const gchar *engine_id = ibus_engine_desc_get_name (engine);
+
+                if (g_str_has_prefix (engine_id, "xkb:"))
+                        g_object_unref (engine);
+                else
+                        g_hash_table_replace (self->ibus_engines, (gpointer)engine_id, engine);
+        }
+
+        update_ibus_active_sources (self);
+        update_input_chooser (self);
+}
+
+static void
+fetch_ibus_engines (CcRegionPanel *self)
+{
+        ibus_bus_list_engines_async (self->ibus,
+                                     -1,
+                                     self->cancellable,
+                                     (GAsyncReadyCallback)fetch_ibus_engines_result,
+                                     self);
+
+  /* We've got everything we needed, don't want to be called again. */
+  g_signal_handlers_disconnect_by_func (self->ibus, fetch_ibus_engines, self);
+}
+
+static void
+maybe_start_ibus (void)
+{
+        /* IBus doesn't export API in the session bus. The only thing
+         * we have there is a well known name which we can use as a
+         * sure-fire way to activate it.
+         */
+        g_bus_unwatch_name (g_bus_watch_name (G_BUS_TYPE_SESSION,
+                                              IBUS_SERVICE_IBUS,
+                                              G_BUS_NAME_WATCHER_FLAGS_AUTO_START,
+                                              NULL,
+                                              NULL,
+                                              NULL,
+                                              NULL));
+}
+
+static GDesktopAppInfo *
+setup_app_info_for_id (const gchar *id)
+{
+        g_autofree gchar *desktop_file_name = NULL;
+        g_auto(GStrv) strv = NULL;
+
+        strv = g_strsplit (id, ":", 2);
+        desktop_file_name = g_strdup_printf ("ibus-setup-%s.desktop", strv[0]);
+
+        return g_desktop_app_info_new (desktop_file_name);
+}
+#endif
+
+static void
+remove_no_input_row (GtkContainer *list)
+{
+        g_autoptr(GList) l = NULL;
+
+        l = gtk_container_get_children (list);
+        if (!l)
+                return;
+        if (l->next != NULL)
+                return;
+        if (g_strcmp0 (g_object_get_data (G_OBJECT (l->data), "type"), "none") == 0)
+                gtk_container_remove (list, GTK_WIDGET (l->data));
+}
+
+static GtkWidget *
+add_input_row (CcRegionPanel   *self,
+               const gchar     *type,
+               const gchar     *id,
+               const gchar     *name,
+               GDesktopAppInfo *app_info)
+{
+        GtkWidget *row;
+        GtkWidget *box;
+        GtkWidget *label;
+        GtkWidget *image;
+
+        remove_no_input_row (GTK_CONTAINER (self->input_list));
+
+        row = gtk_list_box_row_new ();
+        box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_container_add (GTK_CONTAINER (row), box);
+        label = gtk_label_new (name);
+        gtk_widget_set_halign (label, GTK_ALIGN_START);
+        gtk_widget_set_margin_start (label, 20);
+        gtk_widget_set_margin_end (label, 20);
+        gtk_widget_set_margin_top (label, 18);
+        gtk_widget_set_margin_bottom (label, 18);
+        gtk_box_pack_start (GTK_BOX (box), label, TRUE, TRUE, 0);
+
+        if (strcmp (type, INPUT_SOURCE_TYPE_IBUS) == 0) {
+                image = gtk_image_new_from_icon_name ("system-run-symbolic", GTK_ICON_SIZE_BUTTON);
+                gtk_widget_set_margin_start (image, 20);
+                gtk_widget_set_margin_end (image, 20);
+                gtk_widget_set_margin_top (image, 6);
+                gtk_widget_set_margin_bottom (image, 6);
+                gtk_style_context_add_class (gtk_widget_get_style_context (image), "dim-label");
+                gtk_box_pack_start (GTK_BOX (box), image, FALSE, TRUE, 0);
+        }
+
+        gtk_widget_show_all (row);
+        gtk_container_add (GTK_CONTAINER (self->input_list), row);
+
+        g_object_set_data (G_OBJECT (row), "label", label);
+        g_object_set_data (G_OBJECT (row), "type", (gpointer)type);
+        g_object_set_data_full (G_OBJECT (row), "id", g_strdup (id), g_free);
+        if (app_info) {
+                g_object_set_data_full (G_OBJECT (row), "app-info", g_object_ref (app_info), g_object_unref);
+        }
+
+        cc_list_box_adjust_scrolling (GTK_LIST_BOX (self->input_list));
+
+        return row;
+}
+
+static void
+add_no_input_row (CcRegionPanel *self)
+{
+        add_input_row (self, "none", "none", _("No input source selected"), NULL);
+}
+
+static void
+add_input_sources (CcRegionPanel *self,
+                   GVariant      *sources)
+{
+        GVariantIter iter;
+        const gchar *type, *id;
+
+        if (g_variant_n_children (sources) < 1) {
+                add_no_input_row (self);
+                return;
+        }
+
+        g_variant_iter_init (&iter, sources);
+        while (g_variant_iter_next (&iter, "(&s&s)", &type, &id)) {
+                g_autoptr(GDesktopAppInfo) app_info = NULL;
+                g_autofree gchar *display_name = NULL;
+
+                if (g_str_equal (type, INPUT_SOURCE_TYPE_XKB)) {
+                        const gchar *name;
+
+                        gnome_xkb_info_get_layout_info (self->xkb_info, id, &name, NULL, NULL, NULL);
+                        if (!name) {
+                                g_warning ("Couldn't find XKB input source '%s'", id);
+                                continue;
+                        }
+                        display_name = g_strdup (name);
+                        type = INPUT_SOURCE_TYPE_XKB;
+#ifdef HAVE_IBUS
+                } else if (g_str_equal (type, INPUT_SOURCE_TYPE_IBUS)) {
+                        IBusEngineDesc *engine_desc = NULL;
+
+                        if (self->ibus_engines)
+                                engine_desc = g_hash_table_lookup (self->ibus_engines, id);
+                        if (engine_desc)
+                                display_name = engine_get_display_name (engine_desc);
+
+                        app_info = setup_app_info_for_id (id);
+                        type = INPUT_SOURCE_TYPE_IBUS;
+#endif
+                } else {
+                        g_warning ("Unhandled input source type '%s'", type);
+                        continue;
+                }
+
+                add_input_row (self, type, id, display_name ? display_name : id, app_info);
+        }
+}
+
+static void
+add_input_sources_from_settings (CcRegionPanel *self)
+{
+        g_autoptr(GVariant) sources = NULL;
+        sources = g_settings_get_value (self->input_settings, "sources");
+        add_input_sources (self, sources);
+}
+
+static void
+clear_input_sources (CcRegionPanel *self)
+{
+        g_autoptr(GList) list = NULL;
+        GList *l;
+
+        list = gtk_container_get_children (GTK_CONTAINER (self->input_list));
+        for (l = list; l; l = l->next) {
+                gtk_container_remove (GTK_CONTAINER (self->input_list), GTK_WIDGET (l->data));
+        }
+
+        cc_list_box_adjust_scrolling (GTK_LIST_BOX (self->input_list));
+}
+
 static void
 select_by_id (GtkWidget   *row,
               gpointer     data)
@@ -676,6 +891,190 @@ select_by_id (GtkWidget   *row,
                 gtk_list_box_select_row (GTK_LIST_BOX (gtk_widget_get_parent (row)), GTK_LIST_BOX_ROW (row));
 }
 
+static void
+select_input (CcRegionPanel *self,
+              const gchar   *id)
+{
+        gtk_container_foreach (GTK_CONTAINER (self->input_list),
+                               select_by_id, (gpointer)id);
+}
+
+static void
+input_sources_changed (GSettings     *settings,
+                       const gchar   *key,
+                       CcRegionPanel *self)
+{
+        GtkListBoxRow *selected;
+        g_autofree gchar *id = NULL;
+
+        selected = gtk_list_box_get_selected_row (GTK_LIST_BOX (self->input_list));
+        if (selected)
+                id = g_strdup (g_object_get_data (G_OBJECT (selected), "id"));
+        clear_input_sources (self);
+        add_input_sources_from_settings (self);
+        if (id)
+                select_input (self, id);
+}
+
+
+static void
+update_buttons (CcRegionPanel *self)
+{
+        GtkListBoxRow *selected;
+        g_autoptr(GList) children = NULL;
+        guint n_rows;
+
+        children = gtk_container_get_children (GTK_CONTAINER (self->input_list));
+        n_rows = g_list_length (children);
+
+        selected = gtk_list_box_get_selected_row (GTK_LIST_BOX (self->input_list));
+        if (selected == NULL) {
+                gtk_widget_set_visible (self->show_config, FALSE);
+                gtk_widget_set_sensitive (self->remove_input, FALSE);
+                gtk_widget_set_sensitive (self->show_layout, FALSE);
+                gtk_widget_set_sensitive (self->move_up_input, FALSE);
+                gtk_widget_set_sensitive (self->move_down_input, FALSE);
+        } else {
+                GDesktopAppInfo *app_info;
+
+                app_info = (GDesktopAppInfo *)g_object_get_data (G_OBJECT (selected), "app-info");
+
+                gtk_widget_set_visible (self->show_config, app_info != NULL);
+                gtk_widget_set_sensitive (self->show_layout, TRUE);
+                gtk_widget_set_sensitive (self->remove_input, n_rows > 1);
+                gtk_widget_set_sensitive (self->move_up_input, gtk_list_box_row_get_index (selected) > 0);
+                gtk_widget_set_sensitive (self->move_down_input, gtk_list_box_row_get_index (selected) < n_rows - 1);
+        }
+
+        gtk_widget_set_visible (self->options_button,
+                                n_rows > 1 && !self->login);
+}
+
+static void
+set_input_settings (CcRegionPanel *self)
+{
+        const gchar *type;
+        const gchar *id;
+        GVariantBuilder builder;
+        g_autoptr(GList) list = NULL;
+        GList *l;
+
+        g_variant_builder_init (&builder, G_VARIANT_TYPE ("a(ss)"));
+        list = gtk_container_get_children (GTK_CONTAINER (self->input_list));
+        for (l = list; l; l = l->next) {
+                type = (const gchar *)g_object_get_data (G_OBJECT (l->data), "type");
+                id = (const gchar *)g_object_get_data (G_OBJECT (l->data), "id");
+                g_variant_builder_add (&builder, "(ss)", type, id);
+        }
+
+        g_settings_set_value (self->input_settings, KEY_INPUT_SOURCES, g_variant_builder_end (&builder));
+        g_settings_apply (self->input_settings);
+}
+
+static void set_localed_input (CcRegionPanel *self);
+
+static void
+update_input (CcRegionPanel *self)
+{
+        if (self->login) {
+                set_localed_input (self);
+        } else {
+                set_input_settings (self);
+                if (self->login_auto_apply)
+                        set_localed_input (self);
+        }
+}
+
+static gboolean
+input_source_already_added (CcRegionPanel *self,
+                            const gchar   *id)
+{
+        g_autoptr(GList) list = NULL;
+        GList *l;
+
+        list = gtk_container_get_children (GTK_CONTAINER (self->input_list));
+        for (l = list; l; l = l->next)
+                if (g_str_equal (id, (const gchar *) g_object_get_data (G_OBJECT (l->data), "id"))) {
+                        return TRUE;
+                }
+
+        return FALSE;
+}
+
+static void
+run_input_chooser (CcRegionPanel *self, GtkWidget *chooser)
+{
+        if (gtk_dialog_run (GTK_DIALOG (chooser)) == GTK_RESPONSE_OK) {
+                g_autofree gchar *type = NULL;
+                g_autofree gchar *id = NULL;
+                g_autofree gchar *name = NULL;
+
+                if (cc_input_chooser_get_selected (chooser, &type, &id, &name) &&
+                    !input_source_already_added (self, id)) {
+                        g_autoptr(GDesktopAppInfo) app_info = NULL;
+
+                        if (g_str_equal (type, INPUT_SOURCE_TYPE_IBUS)) {
+#ifdef HAVE_IBUS
+                                app_info = setup_app_info_for_id (id);
+#endif
+                        } else {
+                                g_free (type);
+                                type = g_strdup (INPUT_SOURCE_TYPE_XKB);
+                        }
+
+                        add_input_row (self, type, id, name, app_info);
+                        update_buttons (self);
+                        update_input (self);
+                }
+        }
+        gtk_widget_hide(chooser);
+}
+
+static void
+show_input_chooser (CcRegionPanel *self)
+{
+        GtkWidget *chooser;
+        GtkWidget *toplevel;
+
+        chooser = g_object_get_data (G_OBJECT (self), "input-chooser");
+
+        if (!chooser) {
+                toplevel = gtk_widget_get_toplevel (GTK_WIDGET (self));
+                chooser = cc_input_chooser_new (GTK_WINDOW (toplevel),
+                                                self->login,
+                                                self->xkb_info,
+#ifdef HAVE_IBUS
+                                                self->ibus_engines
+#else
+                                                NULL
+#endif
+                                                );
+                g_object_ref (chooser);
+                g_object_set_data_full (G_OBJECT (self), "input-chooser",
+                                        chooser, g_object_unref);
+        } else {
+                cc_input_chooser_reset (chooser);
+        }
+
+        run_input_chooser (self, chooser);
+}
+
+static void
+add_input (CcRegionPanel *self)
+{
+        if (!self->login) {
+                show_input_chooser (self);
+        } else if (g_permission_get_allowed (self->permission)) {
+                show_input_chooser (self);
+        } else if (g_permission_get_can_acquire (self->permission)) {
+                self->op = ADD_INPUT;
+                g_permission_acquire_async (self->permission,
+                                            self->cancellable,
+                                            permission_acquired,
+                                            self);
+        }
+}
+
 static GtkWidget *
 find_sibling (GtkContainer *container, GtkWidget *child)
 {
@@ -701,6 +1100,188 @@ find_sibling (GtkContainer *container, GtkWidget *child)
         return NULL;
 }
 
+static void
+do_remove_selected_input (CcRegionPanel *self)
+{
+        GtkListBoxRow *selected;
+        GtkWidget *sibling;
+
+        selected = gtk_list_box_get_selected_row (GTK_LIST_BOX (self->input_list));
+        if (selected == NULL)
+                return;
+
+        sibling = find_sibling (GTK_CONTAINER (self->input_list), GTK_WIDGET (selected));
+        gtk_container_remove (GTK_CONTAINER (self->input_list), GTK_WIDGET (selected));
+        gtk_list_box_select_row (GTK_LIST_BOX (self->input_list), GTK_LIST_BOX_ROW (sibling));
+
+        cc_list_box_adjust_scrolling (GTK_LIST_BOX (self->input_list));
+
+        update_buttons (self);
+        update_input (self);
+}
+
+static void
+remove_selected_input (CcRegionPanel *self)
+{
+        if (!self->login) {
+                do_remove_selected_input (self);
+        } else if (g_permission_get_allowed (self->permission)) {
+                do_remove_selected_input (self);
+        } else if (g_permission_get_can_acquire (self->permission)) {
+                self->op = REMOVE_INPUT;
+                g_permission_acquire_async (self->permission,
+                                            self->cancellable,
+                                            permission_acquired,
+                                            self);
+        }
+}
+
+static void
+do_move_selected_input (CcRegionPanel *self,
+                        SystemOp       op)
+{
+        GtkListBoxRow *selected;
+        gint idx;
+
+        g_assert (op == MOVE_UP_INPUT || op == MOVE_DOWN_INPUT);
+
+        selected = gtk_list_box_get_selected_row (GTK_LIST_BOX (self->input_list));
+        g_assert (selected);
+
+        idx = gtk_list_box_row_get_index (selected);
+        if (op == MOVE_UP_INPUT)
+                idx -= 1;
+        else
+                idx += 1;
+
+        gtk_list_box_unselect_row (GTK_LIST_BOX (self->input_list), selected);
+
+        g_object_ref (selected);
+        gtk_container_remove (GTK_CONTAINER (self->input_list), GTK_WIDGET (selected));
+        gtk_list_box_insert (GTK_LIST_BOX (self->input_list), GTK_WIDGET (selected), idx);
+        g_object_unref (selected);
+
+        gtk_list_box_select_row (GTK_LIST_BOX (self->input_list), selected);
+
+        cc_list_box_adjust_scrolling (GTK_LIST_BOX (self->input_list));
+
+        update_buttons (self);
+        update_input (self);
+}
+
+static void
+move_selected_input (CcRegionPanel *self,
+                     SystemOp       op)
+{
+        if (!self->login) {
+                do_move_selected_input (self, op);
+        } else if (g_permission_get_allowed (self->permission)) {
+                do_move_selected_input (self, op);
+        } else if (g_permission_get_can_acquire (self->permission)) {
+                self->op = op;
+                g_permission_acquire_async (self->permission,
+                                            self->cancellable,
+                                            permission_acquired,
+                                            self);
+        }
+}
+
+static void
+move_selected_input_up (CcRegionPanel *self)
+{
+        move_selected_input (self, MOVE_UP_INPUT);
+}
+
+static void
+move_selected_input_down (CcRegionPanel *self)
+{
+        move_selected_input (self, MOVE_DOWN_INPUT);
+}
+
+static void
+show_selected_settings (CcRegionPanel *self)
+{
+        GtkListBoxRow *selected;
+        g_autoptr(GdkAppLaunchContext) ctx = NULL;
+        GDesktopAppInfo *app_info;
+        const gchar *id;
+        g_autoptr(GError) error = NULL;
+
+        selected = gtk_list_box_get_selected_row (GTK_LIST_BOX (self->input_list));
+        if (selected == NULL)
+                return;
+
+        app_info = (GDesktopAppInfo *)g_object_get_data (G_OBJECT (selected), "app-info");
+        if  (app_info == NULL)
+                return;
+
+        ctx = gdk_display_get_app_launch_context (gdk_display_get_default ());
+        gdk_app_launch_context_set_timestamp (ctx, gtk_get_current_event_time ());
+
+        id = (const gchar *)g_object_get_data (G_OBJECT (selected), "id");
+        g_app_launch_context_setenv (G_APP_LAUNCH_CONTEXT (ctx),
+                                     "IBUS_ENGINE_NAME", id);
+
+        if (!g_app_info_launch (G_APP_INFO (app_info), NULL, G_APP_LAUNCH_CONTEXT (ctx), &error))
+                g_warning ("Failed to launch input source setup: %s", error->message);
+}
+
+static void
+show_selected_layout (CcRegionPanel *self)
+{
+        GtkListBoxRow *selected;
+        const gchar *type;
+        const gchar *id;
+        const gchar *layout;
+        const gchar *variant;
+        g_autofree gchar *commandline = NULL;
+
+        selected = gtk_list_box_get_selected_row (GTK_LIST_BOX (self->input_list));
+        if (selected == NULL)
+                return;
+
+        type = (const gchar *)g_object_get_data (G_OBJECT (selected), "type");
+        id = (const gchar *)g_object_get_data (G_OBJECT (selected), "id");
+
+        if (g_str_equal (type, INPUT_SOURCE_TYPE_XKB)) {
+                gnome_xkb_info_get_layout_info (self->xkb_info,
+                                                id, NULL, NULL,
+                                                &layout, &variant);
+
+                if (!layout || !layout[0]) {
+                        g_warning ("Couldn't find XKB input source '%s'", id);
+                        return;
+                }
+#ifdef HAVE_IBUS
+        } else if (g_str_equal (type, INPUT_SOURCE_TYPE_IBUS)) {
+                IBusEngineDesc *engine_desc = NULL;
+
+                if (self->ibus_engines)
+                        engine_desc = g_hash_table_lookup (self->ibus_engines, id);
+
+                if (engine_desc) {
+                        layout = ibus_engine_desc_get_layout (engine_desc);
+                        variant = ibus_engine_desc_get_layout_variant (engine_desc);
+                } else {
+                        g_warning ("Couldn't find IBus input source '%s'", id);
+                        return;
+                }
+#endif
+        } else {
+                g_warning ("Unhandled input source type '%s'", type);
+                return;
+        }
+
+        if (variant && variant[0])
+                commandline = g_strdup_printf ("gkbd-keyboard-display -l \"%s\t%s\"",
+                                               layout, variant);
+        else
+                commandline = g_strdup_printf ("gkbd-keyboard-display -l %s",
+                                               layout);
+
+        g_spawn_command_line_async (commandline, NULL);
+}
+
 static void
 options_response (GtkDialog     *options,
                   gint           response_id,
@@ -709,79 +1290,259 @@ options_response (GtkDialog     *options,
         gtk_widget_destroy (GTK_WIDGET (options));
 }
 
+
 static void
-on_localed_properties_changed (GDBusProxy     *proxy,
-                               GVariant       *changed_properties,
-                               const gchar   **invalidated_properties,
-                               CcRegionPanel  *self)
+show_input_options (CcRegionPanel *self)
 {
-        g_autoptr(GVariant) v = NULL;
+        GtkWidget *toplevel;
+        GtkWidget *options;
+
+        toplevel = gtk_widget_get_toplevel (GTK_WIDGET (self));
+        options = cc_input_options_new (toplevel);
+        g_signal_connect (options, "response",
+                          G_CALLBACK (options_response), self);
+        gtk_window_present (GTK_WINDOW (options));
+}
 
-        v = g_dbus_proxy_get_cached_property (proxy, "Locale");
-        if (v) {
-                g_autofree const gchar **strv = NULL;
-                gsize len;
-                gint i;
-                const gchar *lang, *messages, *time;
+static void
+setup_input_section (CcRegionPanel *self)
+{
+        self->input_settings = g_settings_new (GNOME_DESKTOP_INPUT_SOURCES_DIR);
+        g_settings_delay (self->input_settings);
+
+        self->xkb_info = gnome_xkb_info_new ();
+
+#ifdef HAVE_IBUS
+        ibus_init ();
+        if (!self->ibus) {
+                self->ibus = ibus_bus_new_async ();
+                if (ibus_bus_is_connected (self->ibus))
+                        fetch_ibus_engines (self);
+                else
+                        g_signal_connect_object (self->ibus, "connected",
+                                                 G_CALLBACK (fetch_ibus_engines), self,
+                                                 G_CONNECT_SWAPPED);
+        }
+        maybe_start_ibus ();
+#endif
 
-                strv = g_variant_get_strv (v, &len);
+        cc_list_box_setup_scrolling (GTK_LIST_BOX (self->input_list), 5);
 
-                lang = messages = time = NULL;
-                for (i = 0; strv[i]; i++) {
-                        if (g_str_has_prefix (strv[i], "LANG=")) {
-                                lang = strv[i] + strlen ("LANG=");
-                        } else if (g_str_has_prefix (strv[i], "LC_MESSAGES=")) {
-                                messages = strv[i] + strlen ("LC_MESSAGES=");
-                        } else if (g_str_has_prefix (strv[i], "LC_TIME=")) {
-                                time = strv[i] + strlen ("LC_TIME=");
+        gtk_list_box_set_selection_mode (GTK_LIST_BOX (self->input_list),
+                                         GTK_SELECTION_SINGLE);
+        gtk_list_box_set_header_func (GTK_LIST_BOX (self->input_list),
+                                      cc_list_box_update_header_func,
+                                      NULL, NULL);
+        g_signal_connect_object (self->input_list, "row-selected",
+                                 G_CALLBACK (update_buttons), self, G_CONNECT_SWAPPED);
+
+        g_signal_connect (self->input_settings, "changed::" KEY_INPUT_SOURCES,
+                          G_CALLBACK (input_sources_changed), self);
+
+        add_input_sources_from_settings (self);
+        update_buttons (self);
+}
+
+static void
+update_system_locale (CcRegionPanel *self)
+{
+        gchar **lines = NULL;
+        gchar *contents = NULL;
+        gchar *lang = NULL, *messages = NULL, *region = NULL;
+
+        g_file_get_contents ("/etc/default/locale", &contents, NULL, NULL);
+        if (contents) {
+                guint i = 0;
+                lines = g_strsplit (contents, "\n", -1);
+                for (i = 0; lines[i] != NULL; i++) {
+                        if (g_str_has_prefix (lines[i], "LANG=")) {
+                                lang = lines[i] + strlen ("LANG=");
+                        } else if (g_str_has_prefix (lines[i], "LC_MESSAGES")) {
+                                messages = lines[i] + strlen ("LC_MESSAGES=");
+                        } else if (g_str_has_prefix (lines[i], "LC_TIME")) {
+                                region = lines[i] + strlen ("LC_TIME=");
+                        } else if (g_str_has_prefix (lines[i], "LC_NUMERIC")) {
+                                region = lines[i] + strlen ("LC_NUMERIC=");
+                        } else if (g_str_has_prefix (lines[i], "LC_COLLATE")) {
+                                region = lines[i] + strlen ("LC_COLLATE=");
+                        } else if (g_str_has_prefix (lines[i], "LC_MONETARY")) {
+                                region = lines[i] + strlen ("LC_MONETARY=");
+                        } else if (g_str_has_prefix (lines[i], "LC_PAPER")) {
+                                region = lines[i] + strlen ("LC_PAPER=");
+                        } else if (g_str_has_prefix (lines[i], "LC_NAME")) {
+                                region = lines[i] + strlen ("LC_NAME=");
+                        } else if (g_str_has_prefix (lines[i], "LC_ADDRESS")) {
+                                region = lines[i] + strlen ("LC_ADDRESS=");
+                        } else if (g_str_has_prefix (lines[i], "LC_TELEPHONE")) {
+                                region = lines[i] + strlen ("LC_TELEPHONE=");
+                        } else if (g_str_has_prefix (lines[i], "LC_MEASUREMENT")) {
+                                region = lines[i] + strlen ("LC_MEASUREMENT=");
+                        } else if (g_str_has_prefix (lines[i], "LC_IDENTIFICATION")) {
+                                region = lines[i] + strlen ("LC_IDENTIFICATION=");
                         }
                 }
-                if (!lang) {
-                        lang = setlocale (LC_MESSAGES, NULL);
-                }
-                if (!messages) {
-                        messages = lang;
-                }
-                g_free (self->system_language);
-                self->system_language = g_strdup (messages);
-                g_free (self->system_region);
-                self->system_region = g_strdup (time);
+        }
+
+        if (!lang) {
+                lang = setlocale (LC_MESSAGES, NULL);
+        }
+        if (!messages) {
+                messages = lang;
+        }
+        if (!region)
+                region = lang;
+
+        g_free (self->system_language);
+        self->system_language = g_strdup (messages);
+        g_free (self->system_region);
+        self->system_region = g_strdup (region);
+        
+        update_language_label (self);
+
+        if (contents) g_free (contents);
+        if (lines) g_strfreev (lines);
+}
+
+static void
+add_input_sources_from_localed (CcRegionPanel *self)
+{
+        g_autoptr(GVariant) layout_property = NULL;
+        g_autoptr(GVariant) variant_property = NULL;
+        const gchar *s;
+        g_auto(GStrv) layouts = NULL;
+        g_auto(GStrv) variants = NULL;
+        gint i, n;
+
+        if (!self->localed)
+                return;
 
-                update_language_label (self);
+        layout_property = g_dbus_proxy_get_cached_property (self->localed, "X11Layout");
+        if (layout_property) {
+                s = g_variant_get_string (layout_property, NULL);
+                layouts = g_strsplit (s, ",", -1);
+        }
+
+        variant_property = g_dbus_proxy_get_cached_property (self->localed, "X11Variant");
+        if (variant_property) {
+                s = g_variant_get_string (variant_property, NULL);
+                if (s && *s)
+                        variants = g_strsplit (s, ",", -1);
+        }
+
+        if (variants && variants[0])
+                n = MIN (g_strv_length (layouts), g_strv_length (variants));
+        else if (layouts && layouts[0])
+                n = g_strv_length (layouts);
+        else
+                n = 0;
+
+        for (i = 0; i < n && layouts[i][0]; i++) {
+                const gchar *name;
+                g_autofree gchar *id = NULL;
+
+                if (variants && variants[i] && variants[i][0])
+                        id = g_strdup_printf ("%s+%s", layouts[i], variants[i]);
+                else
+                        id = g_strdup (layouts[i]);
+
+                gnome_xkb_info_get_layout_info (self->xkb_info, id, &name, NULL, NULL, NULL);
+
+                add_input_row (self, INPUT_SOURCE_TYPE_XKB, id, name ? name : id, NULL);
+        }
+        if (n == 0) {
+                add_no_input_row (self);
         }
 }
 
 static void
-set_localed_locale (CcRegionPanel *self)
+set_localed_locale (CcRegionPanel *self, gboolean lang_changed)
 {
-        g_autoptr(GVariantBuilder) b = NULL;
-        g_autofree gchar *lang_value = NULL;
+        GError *error = NULL;
+        gchar *cmd = NULL, *pkexec = NULL, *args = NULL;
+
+
+        if (lang_changed) {
+                args = g_strdup_printf ("LANG=%s", self->system_language);
+		} else {
+                args = g_strdup_printf ("LC_TIME=%s LC_NUMERIC=%s "
+                                        "LC_COLLATE=%s LC_MONETARY=%s "
+                                        "LC_PAPER=%s LC_NAME=%s "
+                                        "LC_ADDRESS=%s LC_TELEPHONE=%s "
+                                        "LC_MEASUREMENT=%s LC_IDENTIFICATION=%s",
+                                        self->system_region, self->system_region,
+                                        self->system_region, self->system_region,
+                                        self->system_region, self->system_region,
+                                        self->system_region, self->system_region,
+                                        self->system_region, self->system_region);
+        }
 
-        b = g_variant_builder_new (G_VARIANT_TYPE ("as"));
-        lang_value = g_strconcat ("LANG=", self->system_language, NULL);
-        g_variant_builder_add (b, "s", lang_value);
+        pkexec = g_find_program_in_path ("pkexec");
+        cmd = g_strdup_printf ("%s %s '%s'", pkexec, UPDATE_LOCALE_HELPER, args);
 
-        if (self->system_region != NULL &&
-            g_strcmp0 (self->system_language, self->system_region) != 0) {
-                g_autofree gchar *time_value = NULL;
-                g_autofree gchar *numeric_value = NULL;
-                g_autofree gchar *monetary_value = NULL;
-                g_autofree gchar *measurement_value = NULL;
-                g_autofree gchar *paper_value = NULL;
-                time_value = g_strconcat ("LC_TIME=", self->system_region, NULL);
-                g_variant_builder_add (b, "s", time_value);
-                numeric_value = g_strconcat ("LC_NUMERIC=", self->system_region, NULL);
-                g_variant_builder_add (b, "s", numeric_value);
-                monetary_value = g_strconcat ("LC_MONETARY=", self->system_region, NULL);
-                g_variant_builder_add (b, "s", monetary_value);
-                measurement_value = g_strconcat ("LC_MEASUREMENT=", self->system_region, NULL);
-                g_variant_builder_add (b, "s", measurement_value);
-                paper_value = g_strconcat ("LC_PAPER=", self->system_region, NULL);
-                g_variant_builder_add (b, "s", paper_value);
+        g_spawn_command_line_async (cmd, NULL);
+
+        g_free (args);
+        g_free (pkexec);
+        g_free (cmd);
+}
+
+static void
+locale_file_changed_cb (GFileMonitor      *monitor,
+                        GFile             *file,
+                        GFile             *other_file,
+                        GFileMonitorEvent  event_type,
+                        gpointer           user_data)
+{
+        CcRegionPanel *self = CC_REGION_PANEL (user_data);
+
+        switch (event_type)
+        {
+            case G_FILE_MONITOR_EVENT_CHANGED:
+            case G_FILE_MONITOR_EVENT_DELETED:
+            case G_FILE_MONITOR_EVENT_CREATED:
+            {
+                    update_system_locale (self);
+                    break;
+            }
+
+            default:
+                break;
         }
+}
+
+static void
+set_localed_input (CcRegionPanel *self)
+{
+        g_autoptr(GString) layouts = NULL;
+        g_autoptr(GString) variants = NULL;
+        const gchar *type, *id;
+        g_autoptr(GList) list = NULL;
+        GList *li;
+        const gchar *l, *v;
+
+        layouts = g_string_new ("");
+        variants = g_string_new ("");
+
+        list = gtk_container_get_children (GTK_CONTAINER (self->input_list));
+        for (li = list; li; li = li->next) {
+                type = (const gchar *)g_object_get_data (G_OBJECT (li->data), "type");
+                id = (const gchar *)g_object_get_data (G_OBJECT (li->data), "id");
+                if (g_str_equal (type, INPUT_SOURCE_TYPE_IBUS))
+                        continue;
+
+                if (gnome_xkb_info_get_layout_info (self->xkb_info, id, NULL, NULL, &l, &v)) {
+                        if (layouts->str[0]) {
+                                g_string_append_c (layouts, ',');
+                                g_string_append_c (variants, ',');
+                        }
+                        g_string_append (layouts, l);
+                        g_string_append (variants, v);
+                }
+        }
+
         g_dbus_proxy_call (self->localed,
-                           "SetLocale",
-                           g_variant_new ("(asb)", b, TRUE),
+                           "SetX11Keyboard",
+                           g_variant_new ("(ssssbb)", layouts->str, "", variants->str, "", TRUE, TRUE),
                            G_DBUS_CALL_FLAGS_NONE,
                            -1, NULL, NULL, NULL);
 }
@@ -807,9 +1568,7 @@ localed_proxy_ready (GObject      *source,
 
         gtk_widget_set_sensitive (self->login_button, TRUE);
 
-        g_signal_connect (self->localed, "g-properties-changed",
-                          G_CALLBACK (on_localed_properties_changed), self);
-        on_localed_properties_changed (self->localed, NULL, NULL, self);
+        update_system_locale (self);
 }
 
 static void
@@ -820,13 +1579,30 @@ login_changed (CcRegionPanel *self)
         self->login = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (self->login_button));
         gtk_widget_set_visible (self->login_label, self->login);
 
+        if (self->login) {
+                gtk_revealer_set_reveal_child (GTK_REVEALER (self->restart_revealer), FALSE);
+        } else {
+                g_autoptr(GFile) needs_restart_file = NULL;
+                needs_restart_file = get_needs_restart_file ();
+                if (g_file_query_exists (needs_restart_file, NULL))
+                        set_restart_notification_visible (self, NULL, TRUE);
+        }
+
         can_acquire = self->permission &&
                 (g_permission_get_allowed (self->permission) ||
                  g_permission_get_can_acquire (self->permission));
         /* FIXME: insensitive doesn't look quite right for this */
         gtk_widget_set_sensitive (self->language_section, !self->login || can_acquire);
+        gtk_widget_set_sensitive (self->input_section, !self->login || can_acquire);
+
+        clear_input_sources (self);
+        if (self->login)
+                add_input_sources_from_localed (self);
+        else
+                add_input_sources_from_settings (self);
 
         update_language_label (self);
+        update_buttons (self);
 }
 
 static void
@@ -853,14 +1629,26 @@ setup_login_button (CcRegionPanel *self)
         g_autoptr(GDBusConnection) bus = NULL;
         gboolean loaded;
         g_autoptr(GError) error = NULL;
+        GFile *file;
+        GFileMonitor *monitor;
 
-        self->permission = polkit_permission_new_sync ("org.freedesktop.locale1.set-locale", NULL, NULL, &error);
+        self->permission = polkit_permission_new_sync ("org.gnome.controlcenter.update-locale-helper", NULL, NULL, &error);
         if (self->permission == NULL) {
-                g_warning ("Could not get 'org.freedesktop.locale1.set-locale' permission: %s",
+                g_warning ("Could not get 'org.gnome.controlcenter.update-locale-helper' permission: %s",
                            error->message);
                 return;
         }
 
+        file = g_file_new_for_path ("/etc/default/locale");
+    
+        monitor = g_file_monitor_file (file, G_FILE_MONITOR_NONE, NULL, &error);
+        if (error) {
+            g_error_free (error);
+        } else {
+            g_signal_connect (monitor, "changed", G_CALLBACK (locale_file_changed_cb), self);
+        }
+        g_object_unref (file);
+
         bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
         g_dbus_proxy_new (bus,
                           G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES,
@@ -929,11 +1717,27 @@ cc_region_panel_class_init (CcRegionPanelClass * klass)
         gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, formats_row);
         gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, formats_label);
         gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, restart_revealer);
+        gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, input_section);
+        gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, options_button);
+        gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, input_list);
+        gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, add_input);
+        gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, remove_input);
+        gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, move_up_input);
+        gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, move_down_input);
+        gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, show_config);
+        gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, show_layout);
         gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, restart_button);
         gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, login_label);
         gtk_widget_class_bind_template_child (widget_class, CcRegionPanel, language_list);
 
         gtk_widget_class_bind_template_callback (widget_class, restart_now);
+        gtk_widget_class_bind_template_callback (widget_class, show_input_options);
+        gtk_widget_class_bind_template_callback (widget_class, add_input);
+        gtk_widget_class_bind_template_callback (widget_class, remove_selected_input);
+        gtk_widget_class_bind_template_callback (widget_class, move_selected_input_up);
+        gtk_widget_class_bind_template_callback (widget_class, move_selected_input_down);
+        gtk_widget_class_bind_template_callback (widget_class, show_selected_settings);
+        gtk_widget_class_bind_template_callback (widget_class, show_selected_layout);
 }
 
 static void
@@ -961,6 +1765,7 @@ cc_region_panel_init (CcRegionPanel *self)
 
         setup_login_button (self);
         setup_language_section (self);
+        setup_input_section (self);
 
         needs_restart_file = get_needs_restart_file ();
         if (g_file_query_exists (needs_restart_file, NULL))
diff --git a/panels/region/meson.build b/panels/region/meson.build
index f028829..1998f52 100644
--- a/panels/region/meson.build
+++ b/panels/region/meson.build
@@ -17,13 +17,48 @@ i18n.merge_file(
   install_dir: control_center_desktopdir
 )
 
+polkit_conf = configuration_data()
+polkit_conf.set('libexecdir', control_center_libexecdir)
+
+polkit = 'org.gnome.controlcenter.region.policy'
+
+polkit_in = configure_file(
+  input: polkit + '.in.in',
+  output: polkit + '.in',
+  configuration: polkit_conf
+)
+
+i18n.merge_file(
+  polkit,
+  input: polkit_in,
+  output: polkit,
+  po_dir: po_dir,
+  install: true,
+  install_dir: join_paths(control_center_datadir, 'polkit-1', 'actions')
+)
+
+cflags += [
+  '-DUPDATE_LOCALE_HELPER="@0@"'.format(join_paths(control_center_libexecdir, 'update-locale-helper'))
+]
+
+install_data(
+  ['update-locale-helper'],
+  install_dir: control_center_libexecdir,
+  install_mode: 'rwxr-xr-x',
+)
+
 sources = files(
   'cc-region-panel.c',
   'cc-format-chooser.c',
+  'cc-ibus-utils.c',
+  'cc-input-chooser.c',
+  'cc-input-options.c'
 )
 
 resource_data = files(
   'cc-format-chooser.ui',
+  'input-chooser.ui',
+  'input-options.ui',
   'region.ui'
 )
 
@@ -42,6 +77,10 @@ deps = common_deps + [
   polkit_gobject_dep
 ]
 
+if enable_ibus
+  deps += ibus_dep
+endif
+
 panels_libs += static_library(
   cappletname,
   sources: sources,
diff --git a/panels/region/org.gnome.controlcenter.region.policy.in.in b/panels/region/org.gnome.controlcenter.region.policy.in.in
new file mode 100644
index 0000000..a942845
--- /dev/null
+++ b/panels/region/org.gnome.controlcenter.region.policy.in.in
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE policyconfig PUBLIC
+ "-//freedesktop//DTD PolicyKit Policy Configuration 1.0//EN"
+ "http://www.freedesktop.org/standards/PolicyKit/1.0/policyconfig.dtd">
+<policyconfig>
+
+  <vendor>The GNOME Project</vendor>
+  <action id="org.gnome.controlcenter.update-locale-helper">
+    <defaults>
+      <allow_any>no</allow_any>
+      <allow_inactive>no</allow_inactive>
+      <allow_active>yes</allow_active>
+    </defaults>
+    <annotate key="org.freedesktop.policykit.exec.path">@libexecdir@/update-locale-helper</annotate>
+  </action>
+
+</policyconfig>
diff --git a/panels/region/update-locale-helper b/panels/region/update-locale-helper
new file mode 100755
index 0000000..a9c3106
--- /dev/null
+++ b/panels/region/update-locale-helper
@@ -0,0 +1,2 @@
+#!/bin/sh
+/usr/sbin/update-locale $1
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 69006ee..d6f4800 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -159,6 +159,7 @@ panels/region/cc-format-chooser.ui
 panels/region/cc-input-chooser.c
 panels/region/cc-region-panel.c
 panels/region/gnome-region-panel.desktop.in.in
+panels/region/org.gnome.controlcenter.region.policy.in.in
 panels/region/input-chooser.ui
 panels/region/input-options.ui
 panels/region/region.ui
